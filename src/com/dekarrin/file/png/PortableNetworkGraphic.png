package com.dekarrin.file.png;

import java.util.Vector;
import java.awt.Color;
import java.awt.Point;
import java.util.Calendar;
import java.util.Date;
import com.dekarrin.graphics.*;

/**
 * Represents a PNG file. This class is attempting to be compliant
 * with version 1.2 of the PNG standard; it's not there yet.
 */
public class PortableNetworkGraphic {
	
	/**
	 * Unit specifier for unknown.
	 */
	public static final int UNKNOWN_UNIT = 0;
	
	/**
	 * Unit specifier for the meter.
	 */
	public static final int METER_UNIT = 1;
	
	/**
	 * The background mode for indexed colors.
	 */
	public static final int INDEXED_COLOR_MODE = 0;
	
	/**
	 * The background mode for grayscale.
	 */
	public static final int GRAYSCALE_MODE = 1;
	
	/**
	 * The background mode for truecolor.
	 */
	public static final int TRUECOLOR_MODE = 2;
	
	/**
	 * The rendering intent of perceptual.
	 */
	public static final int RENDERING_INTENT_PERCEPTUAL = 0;
	
	/**
	 * The rendering intent of relative colorimetric.
	 */
	public static final int RENDERING_INTENT_RELATIVE_COLORIMETRIC = 1;
	
	/**
	 * The rendering intent of saturation.
	 */
	public static final int RENDERING_INTENT_SATURATION = 2;
	
	/**
	 * The rendering intent of absolute colorimetric.
	 */
	public static final int RENDERING_INTENT_ABSOLUTE_COLORIMETRIC = 3;
	 
	/**
	 * The compression method value for deflate/inflate.
	 */
	public static final int COMPRESSION_METHOD_ZLIB = 0;
	
	/**
	 * Filter method for adaptive filtering with five basic filter
	 * types.
	 */
	public static final int FILTER_METHOD_ADAPTIVE = 0;
	
	/**
	 * Interlace method for no interlacing.
	 */
	public static final int INTERLACE_METHOD_NONE = 0;
	
	/**
	 * Interlace method for Adam7 interlacing.
	 */
	public static final int INTERLACE_METHOD_ADAM7 = 1;
	
	/**
	 * Color type for no colors.
	 */
	public static final int COLOR_TYPE_GRAYSCALE = 0;
	
	/**
	 * Color type for color used.
	 */
	public static final int COLOR_TYPE_COLOR = 2;
	
	/**
	 * Color type for using both color and a palette.
	 */
	public static final int COLOR_TYPE_COLOR_PALETTE = 3;
	
	/**
	 * Color type for using only an alpha channel.
	 */
	public static final int COLOR_TYPE_GRAYSCALE_ALPHA = 4;
	
	/**
	 * Color type for using both an alpha channel and color.
	 */
	public static final int COLOR_TYPE_COLOR_ALPHA = 6;
	
	/**
	 * The bit depth of this image.
	 */
	private int bitDepth;
	
	/**
	 * The height of this image.
	 */
	private int height;
	
	/**
	 * The width of this image.
	 */
	private int width;
	
	/**
	 * The color type of this image.
	 */
	private int colorType;
	
	/**
	 * Whether or not this png uses interlacing.
	 */
	private boolean adam7Interlacing;
	
	/**
	 * The color palette, if there is one.
	 */
	private Color[] colorPalette;
	
	/**
	 * The alpha palette.
	 */
	private int[] alphaPalette;
	
	/**
	 * The palette frequencies.
	 */
	private int[] frequencies;
	
	/**
	 * The complete palette of this image. This includes
	 * the histogram, if it exists.
	 */
	private Palette palette;
	
	/**
	 * The alpha color.
	 */
	private Color alphaColor;
	
	/**
	 * The image gamma.
	 */
	private int gamma;
	
	/**
	 * The color space for this Image;
	 */
	private Chromaticity chromaticity;
	
	/**
	 * The rendering intent of this image.
	 */
	private int renderingIntent;
	
	/**
	 * The color profile for this png.
	 */
	private IccProfile profile;
	
	/**
	 * The textual data from this png.
	 */
	private HashMap<String,String> textData;
	
	/**
	 * The background color to show the image against.
	 */
	private Color backgroundColor;
	
	/**
	 * A reference to a palette color for use as the
	 * background.
	 */
	private int paletteBackground;
	
	/**
	 * The resolution of this image.
	 */
	private Resolution resolution;
	
	/**
	 * The number of significant bits in the original image.
	 */
	private Color significantColorBits;
	
	/**
	 * The number of significant bits in the original alpha
	 * channel.
	 */
	private int significantAlphaBits;
	
	/**
	 * The suggested reduced palette for this image if the actual
	 * palette cannot be completely rendered.
	 */
	private Palette reducedPalette;
	
	/**
	 * The time that this was last modified.
	 */
	private Date lastModified;
	
	/**
	 * A scanline from the png.
	 */
	private class Scanline {
	
		/**
		 * The filtering method for none.
		 */
		public static final int NO_FILTER = 0;
		
		/**
		 * The filtering method for a sub() filter.
		 */
		public static final int SUB_FILTER = 1;
		
		/**
		 * The filtering method for an up() filter.
		 */
		public static final int UP_FILTER = 2;
		
		/**
		 * The filtering method for an average() filter.
		 */
		public static final int AVERAGE_FILTER = 3;
		
		/**
		 * The filtering method for a paeth() filter.
		 */
		public static final int PAETH_FILTER = 4;
		
		/**
		 * The pixel class.
		 */
		private class Pixel {
		
			private int[] samples;
			
			public Pixel(byte[] data, int sampleCount, int bitDepth) {
				ByteParser p = new ByteParser(data);
				int sampleWidth = bitDepth / 8;
				samples = new int[sampleCount];
				int i = 0;
				while(p.remaining() > 0) {
					samples[i++] = p.parseByte(sampleWidth);
				}
			}
			
			public int[] getSamples() {
				return samples;
			}
		}
	
		/**
		 * The pixels that make up this scanline.
		 */
		private Pixel[] pixels;
		
		/**
		 * The filtering method used for this Scanline.
		 */
		private int filteringMethod;
		
		/**
		 * The bit depth of the containing image.
		 */
		private static int bitDepth;
		
		/**
		 * The number of samples in every pixel of data.
		 */
		private static int samples;
		
		/**
		 * The total length of a scanline in bytes.
		 */
		private static int width;
		
		/**
		 * Creates a new scanline from an unfiltered
		 * byte stream.
		 *
		 * @param byteStream
		 * The stream to create the scanline from.
		 *
		 * @param bitDepth
		 * The bit depth of the image this Scanline is a part of.
		 *
		 * @param sampleCount
		 * The number of samples per pixel of image data.
		 *
		 * @return
		 * The new Scanline.
		 */
		public static getInstanceFromFiltered(byte[] byteStream, int bitDepth, int sampleCount, byte[] lastData) {
			Scanline.width = byteStream.length;
			Scanline.bitDepth = bitDepth;
			Scanline.samples = sampleCount;
			byte[] dataBytes = new byte[width-1];
			ByteParser p = new ByteParser(byteStream);
			int filteringMethod = p.parseInt(1);
			switch(filteringMethod) {
				case NO_FILTER:
					dataBytes = p.parseFinalBytes();
					break;
					
				case SUB_FILTER:
					dataBytes = Scanline.subDefilter(p.parseFinalBytes());
					break;
					
				case UP_FILTER:
					dataBytes = Scanline.upDefilter(p.parseFinalBytes(), lastData);
					break;
					
				case AVERAGE_FILTER:
					dataBytes = Scanline.averageDefilter(p.parseFinalBytes(), lastData);
					break;
					
				case PAETH_FILTER:
					dataBytes = Scanline.paethDefilter(p.parseFinalBytes());
					break;
			}
			Pixel[] pixels = new Pixel[getImageWidth()];
			p = new ByteParser(dataBytes);
			byte[] pixelData = new byte[getPixelWidth()];
			for(int i = 0; i < width; i++) {
				pixelData = p.parseBytes(getPixelWidth());
				pixels[i] = new Pixel(pixelData, Scanline.samples, Scanline.bitDepth);
			}
			return new Scanline(pixels, filteringMethod);
		}
		
		/**
		 * Defilters the data according to the Sub filtering
		 * algorithm.
		 *
		 * @param filteredData
		 * The data to be defiltered.
		 *
		 * @return
		 * The defiltered data.
		 */
		private static byte[] subDefilter(byte[] filteredData) {
			byte[] data = new byte[filteredData.length];
			for(int i = 0; i < getPixelWidth(); i++) {
				data[i] = filteredData[i];
			}
			for(int i = getPixelWidth(); i < filteredData.length; i++) {
				data[i] = filteredData[i] + data[i-getPixelWidth()];
			}
			return data;
		}
		
		/**
		 * Defilters the data according to the Up filtering
		 * algorithm.
		 *
		 * @param filteredData
		 * The data to be defiltered.
		 *
		 * @param lastData
		 * The set of the last data. This must be the unfiltered
		 * version.
		 *
		 * @return
		 * The defiltered data.
		 */
		private static byte[] upDefilter(byte[] filteredData, byte[] lastData) {
			byte[] data = new byte[filteredData.length];
			if(lastData == null) {
				data = filteredData;
			} else {
				for(int i = 0; i < filteredData.length; i++) {
					data[i] = filteredData[i] + lastData[i];
				}
			}
		}
		
		/**
		 * Defilters the data according to the Average filtering
		 * algorithm.
		 *
		 * @param filteredData
		 * The data to be defiltered.
		 *
		 * @param lastData
		 * The set of the last data. This must be the unfiltered
		 * version.
		 *
		 * @return
		 * The defiltered data.
		 */
		private static byte[] averageDefilter(byte[] filteredData, byte[] lastData) {
			byte[] data = new byte[filteredData.length];
		}
		
		/**
		 * Filters the data according to the Sub filtering
		 * algorithm.
		 *
		 * @param unfilteredData
		 * The data to be filtered.
		 *
		 * @return
		 * The filtered data.
		 */
		private static byte[] subFilter(byte[] unfilteredData) {
			byte[] filteredData = new byte[unfilteredData.length];
			for(int i = 0; i < getPixelWidth(); i++) {
				filteredData[i] = unfilteredData[i];
			}
			for(int i = getPixelWidth(); i < unfilteredData.length; i++) {
				filteredData[i] = unfilteredData[i] + filteredData[i-getPixelWidth()];
			}
			return filteredData;
		}
		
		/**
		 * Gets the width of a single pixel.
		 *
		 * @return
		 * The width of a pixel in bytes.
		 */
		private static int getPixelWidth() {
			int width = Scanline.samples * (Scanline.bitDepth / 8);
			return width;
		}
		
		/**
		 * Gets the width in pixels of the entire image.
		 *
		 * @return
		 * The width of the image.
		 */
		private static int getImageWidth() {
			int width = Scanline.width / getPixelWidth();
			return width;
		}
		
		/**
		 * Creates a new scanline from a series of pixels.
		 *
		 * @param pixels
		 * The pixels that make up the new Scanline.
		 */
		public Scanline(Pixel[] pixels, int filteringMethod) {
			this.pixels = pixels;
			this.filteringMethod = filteringMethod;
		}
		
		/**
		 * Gets the exact bytes of this scanline.
		 *
		 * @return
		 * The bytes.
		 */
		public getBytes() {
			byte[] data = new byte[width];
			data[0] = (byte)filteringMethod;
			int p = 1;
			for(int i = 0; i < pixels.length; i++) {
				int[] samples = pixels[i].getSamples();
				for(int j: samples) {
					data[p++] = (byte)j;
				}
			}
			return data;
		}
	}

	/**
	 * Creates a new PNG from a series of chunks.
	 *
	 * @param chunks
	 * The chunks to generate the png from.
	 */
	public PortableNetworkGraphic(Chunk[] chunks) {
		Vector<ImageDataChunk> idatChunks = new Vector<ImageDataChunk>();
		for(Chunk c: chunks) {
			String type = c.getTypeName();
			
			if(type.equals("IHDR")) {
				readHeaderChunk(c);
			} else if(type.equals("PLTE")) {
				readPaletteChunk(c);
			} else if(type.equals("IDAT")) {
				idatChunks.add(c);
			} else if(type.equals("IEND")) {
				break;//do not read past an iend, even if there is more data.
			} else if(type.equals("tRNS")) {
				readTransparencyChunk(c);
			} else if(type.equals("gAMA")) {
				readGammaChunk(c);
			} else if(type.equals("cHRM")) {
				readChromaticitiesChunk(c);
			} else if(type.equals("sRGB")) {
				readStandardRgbColorSpaceChunk(c);
			} else if(type.equals("iCCP")) {
				readEmbeddedColorProfileChunk(c);
			} else if(type.equals("tEXt") || type.equals("zTXt") || type.equals("iTXt")) {
				readTextChunk(c);
			} else if(type.equals("bKGD")) {
				readBackgroundColorChunk(c);
			} else if(type.equals("pHYs")) {
				readPhysicalPixelDimensionsChunk(c);
			} else if(type.equals("sBIT")) {
				readSignificantBitsChunk(c);
			} else if(type.equals("sPLT")) {
				readSuggestedPaletteChunk(c);
			} else if(type.equals("hIST")) {
				readPaletteHistogramChunk(c);
			} else if(type.equals("tIME")) {
				readLastModificationTimeChunk(c);
			}
		}
		finishChunkDecoding();
		decodeImageData(idatChunks.toArray(new ImageDataChunk[0]);
	}
	
	/**
	 * Builds an image from image data chunks.
	 *
	 * @param chunks
	 * The image chunks that make up the image data.
	 */
	private void decodeImageData(ImageDataChunk[] chunks) {
		byte[] compressedData = extractData(chunks);
		byte[] decompressedData = decompressData(compressedData);
		byte[][] lines = extractScanlines(decompressedData);
		Scanline[] rawData = new Scanline[compressedData.length];
		for(int i = 0; i < lines.length; i++) {
			int samples;
			switch(colorMode) {
				case COLOR_TYPE_GRAYSCALE:
					samples = 1;
					break;
					
				case COLOR_TYPE_COLOR:
					samples = 3;
					break;

				case COLOR_TYPE_COLOR_PALETTE:
					samples = 1;
					break;
			
				case COLOR_TYPE_GRAYSCALE_ALPHA:
					samples = 2;
					break;
	
				case COLOR_TYPE_COLOR_ALPHA:
					samples = 4;
					break;
			}
			byte[] l = (i > 0) ? (rawData[i-1].getBytes()) : null;
			rawData[i] = Scanline.getInstanceFromFiltered(lines[i], bitDepth, samples, l);
		}
		constructImage(rawData);
	}
	
	/**
	 * Seperates the raw image data into scanline series. Each of
	 * the scanline series will be the filtered byte stream of a
	 * scanline.
	 *
	 * @param data
	 * The raw uncompressed image data.
	 * 
	 * @return
	 * The raw data seperated into scanline series.
	 */
	private byte[][] extractScanlines(byte[] data) {
		scanlineLength = getScanlineLength();
		byte[][] lines = new byte[height][scanlineWidth];
		byte[] buffer = new byte[scanlineWidth];
		int currentByte = 0;
		int currentLine = 0;
		for(int i = 0; i < data.length; i++) {
			lines[currentLine][currentByte++] = data[i];
			if(currentByte == scanlineWidth) {
				currentLine++;
				currentByte = 0;
			}
		}
		return lines;
	}
	
	/**
	 * Decompresses a byte array.
	 *
	 * @param data
	 * The compressed data.
	 *
	 * @return
	 * The decompressed data.
	 */
	private byte[] decompressData(byte[] data) {
		ZlibDecompresser decompresser = new ZlibDecompresser(data);
		return decompresser.decompress();
	}
	
	/**
	 * Gets only the raw data from a series of chunks. The
	 * data is then concatenated.
	 *
	 * @param chunks
	 * The chunks whose data is to be concatenated.
	 *
	 * @return
	 * The data as a byte array.
	 */
	private byte[] extractData(Chunk[] chunks) {
		int dataLength = 0;
		for(Chunk c: chunks) {
			dataLength += c.getLength();
		}
		byte[] data = new byte[dataLength];
		int dataPointer = 0;
		byte[] chunkData;
		for(Chunk c: chunks) {
			chunkData = c.getData();
			for(byte b: chunkData) {
				data[dataPointer++] = b;
			}
		}
		return data;
	}
	
	/**
	 * Gets the last modified information from that chunk.
	 *
	 * @param chunk
	 * The last modification time chunk.
	 */
	private void readLastModificationTimeChunk(LastModificationTimeChunk chunk) {
		Calendar c = Calendar.getInstance();
		c.set(chunk.getYear(), chunk.getMonth(), chunk.getDay(), chunk.getHour(), chunk.getMinute(), chunk.getSecond());
		lastModified = c.getTime();
	}
	
	/**
	 * Gets the histogram information from the chunk data.
	 *
	 * @param chunk
	 * The palette histogram chunk.
	 */
	private void readPaletteHistogramChunk(PaletteHistogramChunk chunk) {
		frequencies = chunk.getFrequencies();
	}
	
	/**
	 * Reads the suggested palette from the chunk data.
	 *
	 * @param chunk
	 * The suggested palette chunk.
	 */
	private void readSuggestedPaletteChunk(SuggestedPaletteChunk chunk) {
		Color[] c = chunk.getPaletteEntries();
		int[] f = chunk.getFrequencies();
		reducedPalette = new Palette(chunk.getPaletteName(), chunk.getSampleDepth(), c, f);
	}
	
	/**
	 * Reads the number of significant bits present in the original
	 * file.
	 *
	 * @param chunk
	 * The SignificantBitsChunk.
	 */
	private void readSignificantBitsChunk(SignificantBitsChunk chunk) {
		significantColorBits = chunk.getColorBits();
		if(colorMode == COLOR_TYPE_GRAYSCALE_ALPHA || colorMode == COLOR_TYPE_COLOR_ALPHA) {
			significantAlphaBits = chunk.getAlphaBits();
		}
	}
	
	/**
	 * Reads a header chunk and assigns properties based on it.
	 *
	 * @param header
	 * The header chunk.
	 */
	private void readHeaderChunk(HeaderChunk header) {
		bitDepth = header.getBitDepth();
		height = header.getHeight();
		width = header.getWidth();
		colorType = header.getColorType();
	}
	
	/**
	 * Reads dimensions.
	 *
	 * @param chunk
	 * The dimension chunk.
	 */
	private void readPhysicalDimensionsChunk(PhysicalDimensionsChunk chunk) {
		resolution = new Resolution(chunk.getWidth(), chunk.getHeight());
	}
	
	/**
	 * Reads some text data into this png.
	 *
	 * @param chunk
	 * The chunk containing text data.
	 */
	private void readTextChunk(TextChunk chunk) {
		if(textData == null) {
			textData = new HashMap<String,String>();
		}
		textData.put(chunk.getKeyword(), chunk.getText());
	}
	
	/**
	 * Reads an embedded color profile.
	 *
	 * @param chunk
	 * The ICCP chunk.
	 */
	private void readEmbeddedColorProfileChunk(EmbeddedColorProfileChunk chunk) {
		profile = new IccProfile(chunk.getProfileName(), chunk.getProfile());
	}
	
	/**
	 * Reads a palette chunk and assigns properties based on it.
	 *
	 * @param chunk
	 * The palette chunk.
	 */
	private void readPaletteChunk(PaletteChunk chunk) {
		colorPalette = chunk.getPalette();
	}
	
	/**
	 * Reads a chromaticites chunk and assigns properties based
	 * on it.
	 *
	 * @param chunk
	 * The chromaticites chunk.
	 */
	private void readChromaticitiesChunk(ChromaticitiesChunk chunk) {
		Point r = chunk.getRed();
		Point g = chunk.getGreen();
		Point b = chunk.getBlue();
		Point w = chunk.getWhitePoint();
		chromaticity = new Chromaticity(r, g, b, w);
	}
	
	/**
	 * Reads a transparency chunk and assigns properties based
	 * on it.
	 *
	 * @param chunk
	 * The transparency chunk.
	 */
	private void readTransparencyChunk(TransparencyChunk chunk) {
		if(chunk.getColorMode() == colorMode) {
			switch(chunk.getColorMode()) {
				case COLOR_TYPE_GRAYSCALE:
				case COLOR_TYPE_COLOR:
					alphaColor = chunk.getAlpha();
					break;
					
				case COLOR_TYPE_COLOR_PALETTE:
					alphaPalette = chunk.getPaletteAlphas();
					break;
			}
		} else {
			throw new RuntimeException("Color mode mismatch!");
		}
	}
	
	/**
	 * Reads a gamma chunk and assigns properties based on it.
	 *
	 * @param chunk
	 * The gamma chunk.
	 */
	private void readGammaChunk(GammaChunk chunk) {
		gamma = getGamma();
	}
	
	/**
	 * Reads a standard RGB color space chunk and assigns
	 * properties based on it.
	 *
	 * @param chunk
	 * The standard RGB color space chunk.
	 */
	private void readStandardRgbColorSpaceChunk(StandardRgbColorSpaceChunk chunk) {
		renderingIntent = chunk.getRenderingIntent();
	}
	
	/**
	 * Reads the background color from a chunk.
	 *
	 * @param chunk.
	 * The background color chunk.
	 */
	private void readBackgroundColorChunk(BackgroundColorChunk chunk) {
		if(chunk.getColorMode() == colorMode) {
			switch(chunk.getColorMode()) {
				case COLOR_TYPE_GRAYSCALE:
				case COLOR_TYPE_COLOR:
					backgroundColor = chunk.getColor();
					break;
					
				case COLOR_TYPE_COLOR_PALETTE:
					paletteBackground = chunk.getPaletteIndex();
					break;
			}
		} else {
			throw new RuntimeException("Color mode mismatch!");
		}
	}
	
	/**
	 * Assembles partial components of read objects into their
	 * completed versions.
	 */
	private void finishChunkDecoding() {
	
	}
}
